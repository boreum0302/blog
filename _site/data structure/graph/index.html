<!DOCTYPE html>
<!--
    So Simple Jekyll Theme 3.2.0
    Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
    Free for personal and commercial use under the MIT license
    https://github.com/mmistakes/so-simple-theme/blob/master/LICENSE
-->
<html lang="en-US" class="no-js">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  

  
    
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>파이썬 자료구조: 그래프 | YONDU UDONTA</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="파이썬 자료구조: 그래프" />
<meta name="author" content="Yondu Udonta" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="정점(vertex)들과 두 개의 정점을 잇는 간선(edge)들의 집합인 그래프(graph)는 광범위한 분야에 활용되는 자료구조이다. 그래프에 관한 용어들을 정리한 다음, 그래프에 속한 정점들을 빠짐없이 방문하는 두 가지 기본 연산인 깊이 우선 탐색(depth first search)과 너비 우선 탐색(breadth first search)을 구현했다. 그리고 최소 신장 트리(minimum spanning tree)를 찾는 Kruskal 알고리즘과 Prim 알고리즘, 최단 경로(shortest path)를 찾는 Dijkstra 알고리즘과 Floyd-Warshall 알고리즘에 대해 정리했다." />
<meta property="og:description" content="정점(vertex)들과 두 개의 정점을 잇는 간선(edge)들의 집합인 그래프(graph)는 광범위한 분야에 활용되는 자료구조이다. 그래프에 관한 용어들을 정리한 다음, 그래프에 속한 정점들을 빠짐없이 방문하는 두 가지 기본 연산인 깊이 우선 탐색(depth first search)과 너비 우선 탐색(breadth first search)을 구현했다. 그리고 최소 신장 트리(minimum spanning tree)를 찾는 Kruskal 알고리즘과 Prim 알고리즘, 최단 경로(shortest path)를 찾는 Dijkstra 알고리즘과 Floyd-Warshall 알고리즘에 대해 정리했다." />
<link rel="canonical" href="http://localhost:4000/data%20structure/graph/" />
<meta property="og:url" content="http://localhost:4000/data%20structure/graph/" />
<meta property="og:site_name" content="YONDU UDONTA" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-14T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="파이썬 자료구조: 그래프" />
<meta name="google-site-verification" content="UQj93ERU9zgECodaaXgVpkjrFn9UrDMEzVamacSoQ8Y" />
<script type="application/ld+json">
{"@type":"BlogPosting","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/images/yondu-udonta-logo.png"},"name":"Yondu Udonta"},"headline":"파이썬 자료구조: 그래프","dateModified":"2020-05-14T00:00:00+09:00","datePublished":"2020-05-14T00:00:00+09:00","url":"http://localhost:4000/data%20structure/graph/","author":{"@type":"Person","name":"Yondu Udonta"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/data%20structure/graph/"},"description":"정점(vertex)들과 두 개의 정점을 잇는 간선(edge)들의 집합인 그래프(graph)는 광범위한 분야에 활용되는 자료구조이다. 그래프에 관한 용어들을 정리한 다음, 그래프에 속한 정점들을 빠짐없이 방문하는 두 가지 기본 연산인 깊이 우선 탐색(depth first search)과 너비 우선 탐색(breadth first search)을 구현했다. 그리고 최소 신장 트리(minimum spanning tree)를 찾는 Kruskal 알고리즘과 Prim 알고리즘, 최단 경로(shortest path)를 찾는 Dijkstra 알고리즘과 Floyd-Warshall 알고리즘에 대해 정리했다.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  

  <script>
    /* Cut the mustard */
    if ( 'querySelector' in document && 'addEventListener' in window ) {
      document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + 'js';
    }
  </script>

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/skins/default.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+KR:200,600|Noto+Sans+KR:200,600|Nanum+Gothic+Coding:400,700">
  <link rel="alternate" type="application/atom+xml" title="YONDU UDONTA" href="/atom.xml">
<!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

</head>

  
  <head>
    
      <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$'] ],
    processEscapes: true,
  }
});
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

    
  </head>  

  <body class="layout--post  파이썬-자료구조-그래프">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#primary-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    
  <div class="navigation-wrapper">
    <a href="#menu-toggle" id="menu-toggle">Menu</a>
    <nav id="primary-nav" class="site-nav animated drop">
      <ul><li><a href="/posts/">Posts</a></li><li><a href="/categories/">Categories</a></li><li><a href="/tags/">Tags</a></li><li><a href="/photos/">Photos</a></li><li><a href="/search/">Search</a></li></ul>
    </nav>
  </div><!-- /.navigation-wrapper -->


    <header class="masthead">
  <div class="wrap">
    
      <a href="/" class="site-logo" rel="home" title="YONDU UDONTA">
        <img src="/images/yondu-udonta-logo.png" class="site-logo-img animated fadeInDown" alt="YONDU UDONTA">
      </a>
    
    
    
      
        <div class="site-title animated fadeIn"><a href="/">YONDU UDONTA</a></div>
      
      <p class="site-description animated fadeIn" itemprop="description">I'm Mary Poppins, Y'all!</p>
    
  </div>
</header><!-- /.masthead -->


    <style>
  .e-content{
  text-align:justify}
</style>

<main id="main" class="main-content" aria-label="Content">
  <article class="h-entry">
    

    <div class="page-wrapper">
      <header class="page-header">
        
        
          <h1 id="page-title" class="page-title p-name">파이썬 자료구조: 그래프
</h1>
        
      </header>

      <div class="page-sidebar">
        <div class="page-author h-card p-author"><img src="/images/yondu-udonta-logo.png" class="author-avatar u-photo" alt="Yondu Udonta"><div class="author-info"><div class="author-name">
        <em>by</em> <span class="p-name">Yondu Udonta</span>
      </div><ul class="author-links"><li class="author-link">
            <a class="u-url" rel="me" href="https://github.com/boreum0302"><i class="fab fa-github-square fa-lg" title="GitHub"></i></a>
          </li><li class="author-link">
            <a class="u-url" rel="me" href="mailto:bureom0302@gmail.com"><i class="fas fa-envelope-square fa-lg" title="e-mail"></i></a>
          </li></ul>
    <time class="page-date dt-published" datetime="2020-05-14T00:00:00+09:00"><a class="u-url" href="">May 14, 2020</a>
</time>

  </div>
</div>

        
  <h3 class="page-taxonomies-title">Categories</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a class="p-category" href="/categories/#data-structure" title="Pages filed under Data Structure">Data Structure</a></li>
  </ul>


        
  <h3 class="page-taxonomies-title">Tags</h3>
  
  <ul class="page-taxonomies"><li class="page-taxonomy"><a href="/tags/#python" title="Pages tagged python" rel="tag">python</a></li>
  </ul>


      </div>

      <div class="page-content">
        <div class="e-content">
          <p>정점(vertex)들과 두 개의 정점을 잇는 간선(edge)들의 집합인 그래프(graph)는 광범위한 분야에 활용되는 자료구조이다. 그래프에 관한 용어들을 정리한 다음, 그래프에 속한 정점들을 빠짐없이 방문하는 두 가지 기본 연산인 깊이 우선 탐색(depth first search)과 너비 우선 탐색(breadth first search)을 구현했다. 그리고 최소 신장 트리(minimum spanning tree)를 찾는 <code class="language-plaintext highlighter-rouge">Kruskal</code> 알고리즘과 <code class="language-plaintext highlighter-rouge">Prim</code> 알고리즘, 최단 경로(shortest path)를 찾는 <code class="language-plaintext highlighter-rouge">Dijkstra</code> 알고리즘과 <code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 알고리즘에 대해 정리했다.</p>

<ul id="markdown-toc">
  <li><a href="#그래프graph" id="markdown-toc-그래프graph">그래프(graph)</a></li>
  <li><a href="#깊이-우선-탐색depth-first-search" id="markdown-toc-깊이-우선-탐색depth-first-search">깊이 우선 탐색(depth first search)</a>    <ul>
      <li><a href="#연결성분connected-component-찾기" id="markdown-toc-연결성분connected-component-찾기">연결성분(connected component) 찾기</a></li>
      <li><a href="#강연결성분strongly-connected-component-찾기" id="markdown-toc-강연결성분strongly-connected-component-찾기">강연결성분(strongly connected component) 찾기</a></li>
      <li><a href="#위상-정렬topological-sort-하기" id="markdown-toc-위상-정렬topological-sort-하기">위상 정렬(topological sort) 하기</a></li>
    </ul>
  </li>
  <li><a href="#너비-우선-탐색breadth-first-search" id="markdown-toc-너비-우선-탐색breadth-first-search">너비 우선 탐색(breadth first search)</a></li>
  <li><a href="#최소-신장-트리minimum-spanning-tree" id="markdown-toc-최소-신장-트리minimum-spanning-tree">최소 신장 트리(minimum spanning tree)</a>    <ul>
      <li><a href="#kruskal" id="markdown-toc-kruskal"><code class="language-plaintext highlighter-rouge">Kruskal</code></a></li>
      <li><a href="#prim" id="markdown-toc-prim"><code class="language-plaintext highlighter-rouge">Prim</code></a></li>
    </ul>
  </li>
  <li><a href="#최단-경로shortest-path" id="markdown-toc-최단-경로shortest-path">최단 경로(shortest path)</a>    <ul>
      <li><a href="#dijkstra" id="markdown-toc-dijkstra"><code class="language-plaintext highlighter-rouge">Dijkstra</code></a></li>
      <li><a href="#floyd-warshall" id="markdown-toc-floyd-warshall"><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code></a></li>
    </ul>
  </li>
</ul>

<h1 id="그래프graph">그래프(graph)</h1>

<p>그래프에 대한 용어에는 아래와 같은 것들이 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">용어</th>
      <th style="text-align: left">정의</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">방향 그래프(directed graph)</td>
      <td style="text-align: left">간선에 방향이 있는 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">무방향 그래프(undirected graph)</td>
      <td style="text-align: left">간선에 방향이 없는 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">가중치 그래프(weighted graph)</td>
      <td style="text-align: left">간선에 가중치가 부여된 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">차수(degree)</td>
      <td style="text-align: left">(무방향 그래프에서) 주어진 정점에 인접한 정점의 수</td>
    </tr>
    <tr>
      <td style="text-align: left">진입 차수(in-degree)</td>
      <td style="text-align: left">(방향 그래프에서) 주어진 정점으로 들어오는 간선의 수</td>
    </tr>
    <tr>
      <td style="text-align: left">진출 차수(out-degree)</td>
      <td style="text-align: left">(방향 그래프에서) 주어진 정점에서 나가는 간선의 수</td>
    </tr>
    <tr>
      <td style="text-align: left">경로(path)</td>
      <td style="text-align: left">인접한 정점들의 나열</td>
    </tr>
    <tr>
      <td style="text-align: left">단순 경로(simple path)</td>
      <td style="text-align: left">정점들이 겹치지 않는 경로</td>
    </tr>
    <tr>
      <td style="text-align: left">사이클(cycle)</td>
      <td style="text-align: left">시작 정점과 끝 정점이 일치하는 단순 경로</td>
    </tr>
    <tr>
      <td style="text-align: left">부분 그래프(subgraph)</td>
      <td style="text-align: left">주어진 그래프의 일부 정점과 일부 간선으로 이루어진 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">희소 그래프(sparse graph)</td>
      <td style="text-align: left">정점의 차수가 작은 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">조밀 그래프(dense graph)</td>
      <td style="text-align: left">정점의 차수가 커서 간선의 수가 최대 간선 수에 가까운 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">연결성분(connected component)</td>
      <td style="text-align: left">임의의 두 정점 사이에 경로가 존재하는 최대 크기의 부분 그래프</td>
    </tr>
    <tr>
      <td style="text-align: left">단절 정점(articulation point)</td>
      <td style="text-align: left">연결성분에서 하나의 단절 정점을 삭제하면 두 개 이상의 연결성분으로 분리됨</td>
    </tr>
    <tr>
      <td style="text-align: left">이중연결성분(biconnected component)</td>
      <td style="text-align: left">(무방향 그래프에서) 단절 정점이 존재하지 않는 연결성분</td>
    </tr>
    <tr>
      <td style="text-align: left">강연결성분(strongly connected component)</td>
      <td style="text-align: left">(방향 그래프에서) 임의의 두 정점 <code class="language-plaintext highlighter-rouge">v1</code>과 <code class="language-plaintext highlighter-rouge">v2</code>에 대해 <code class="language-plaintext highlighter-rouge">v1</code>에서 <code class="language-plaintext highlighter-rouge">v2</code>으로 가는 경로와 <code class="language-plaintext highlighter-rouge">v2</code>에서 <code class="language-plaintext highlighter-rouge">v1</code>으로 가는 경로가 존재하는 연결성분</td>
    </tr>
    <tr>
      <td style="text-align: left">신장 트리(spanning tree)</td>
      <td style="text-align: left">하나의 연결성분으로 구성된 그래프에서 모든 정점들을 사이클 없이 연결하는 부분그래프</td>
    </tr>
  </tbody>
</table>

<p>그래프를 저장하기 위해 일반적으로 인접행렬(adjacency matrix)과 인접리스트(adjacency list)를 사용한다(둘 다 중첩 리스트임).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">용어</th>
      <th style="text-align: left">정의</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">인접행렬</td>
      <td style="text-align: left">(무방향 그래프에서) 정점 <code class="language-plaintext highlighter-rouge">i</code>와 <code class="language-plaintext highlighter-rouge">j</code>를 잇거나 (방향 그래프에서) 정점 <code class="language-plaintext highlighter-rouge">i</code>에서 <code class="language-plaintext highlighter-rouge">j</code>로 향하는 간선이 존재하면 <code class="language-plaintext highlighter-rouge">A[i][j]</code>의 값은 1이고 아니면 0임</td>
    </tr>
    <tr>
      <td style="text-align: left">인접리스트</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">A[i]</code>의 값은 정점 <code class="language-plaintext highlighter-rouge">i</code>에 인접한 다른 정점들의 리스트임</td>
    </tr>
  </tbody>
</table>

<h1 id="깊이-우선-탐색depth-first-search">깊이 우선 탐색(depth first search)</h1>

<p><img src="/images/2020-05-13-dfs-and-bfs.gif" alt="(1)" class="align-center" /></p>

<p>그래프가 인접리스트로 저장되어 있는 경우 깊이 우선 탐색(depth first search)과 너비 우선 탐색(breadth first search)을 사용하면 \(O(V+E)\)의 시간에 정점들을 빠짐없이 방문할 수 있다(\(V\)는 정점의 수이고 \(E\)는 간선의 수임). 임의의 정점에서부터 깊이 우선 탐색을 하는 경우 인접한 정점을 방문한 뒤 방금 방문한 정점에 인접한 다른 정점을 방문하는 식으로 탐색이 일어난다. 더 이상 인접한 정점에 방문할 수 없다면 아직 방문하지 않은 다른 정점에서부터 탐색을 다시 시작한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">def</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">adj_list</span><span class="p">):</span>  <span class="c1"># adj_list는 인접리스트임
</span>        
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>  <span class="c1"># visited[i]의 값은 정점 i를 방문했다면 True이고 아니면 False임
</span>    <span class="n">dfs_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 방문한 정점들이 담길 리스트임
</span>       
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># 정점 v에서부터 탐색 시작하기
</span>    
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 정점 v를 방문하기
</span>        <span class="n">dfs_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 정점 v를 dfs_list에 담기
</span>        
        <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 방금 방문한 정점 v에 인접한 정점들 adj_v에 대해서
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v를 아직 방문하지 않았다면
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>  <span class="c1"># adj_v에서부터 다시 탐색 시작하기
</span>        
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">dfs_list</span>
</code></pre></div></div>

<h2 id="연결성분connected-component-찾기">연결성분(connected component) 찾기</h2>

<p>깊이 우선 탐색을 변형하여 무방향그래프에서 연결성분을 찾을 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">CC</span><span class="p">(</span><span class="n">adj_list</span><span class="p">):</span>  <span class="c1"># adj_list는 인접리스트임
</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>  <span class="c1"># visited[i]의 값은 정점 i를 방문했다면 True이고 아니면 False임
</span>    <span class="n">CClist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 연결성분들이 담길 리스트임
</span>        
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># 정점 v에서부터 탐색 시작하기
</span>    
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 정점 v를 방문하기
</span>        <span class="n">cclist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 정점 v를 연결성분에 담기
</span>        
        <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 방금 방문한 정점 v에 인접한 정점들 adj_v에 대해서
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v를 아직 방문하지 않았다면
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>  <span class="c1"># adj_v에서부터 다시 탐색 시작하기
</span>                
        <span class="c1"># 정점 v와 연결된 정점들을 전부 방문했다면 함수는 더 이상 실행되지 않음
</span>        
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 정점 v를 아직 방문하지 않았다면
</span>            <span class="n">cclist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 정점 v가 속해 있는 연결성분을 담을 리스트 초기화하기
</span>            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 정점 v와 연결된 정점들을 전부 방문하여 연결성분에 담기
</span>            <span class="n">CClist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cclist</span><span class="p">)</span>  <span class="c1"># CClist에 정점 v가 속해 있는 연결성분을 담기
</span>        
    <span class="k">return</span> <span class="n">CClist</span>
</code></pre></div></div>

<h2 id="강연결성분strongly-connected-component-찾기">강연결성분(strongly connected component) 찾기</h2>

<p><code class="language-plaintext highlighter-rouge">Kosaraju</code> 알고리즘은 깊이 우선 탐색을 활용하여 방향 그래프에서 강연결성분을 찾는다. 주어진 방향 그래프와 역방향 그래프의 강연결성분은 완전히 동일하다는 사실을 이용하지만 증명은 어려워서 이해하지 못했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Kosaraju</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">):</span>  <span class="c1"># adj_list는 인접행렬임
</span>    
    <span class="n">N</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">BCClist</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">),</span> <span class="p">[],</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">rev_dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">adj_v</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>
                <span class="n">rev_dfs</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>
        <span class="n">bcclist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  
        
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">bcclist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">rev_dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">BCClist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcclist</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">BCClist</span>
</code></pre></div></div>

<h2 id="위상-정렬topological-sort-하기">위상 정렬(topological sort) 하기</h2>

<p>위상 정렬(topological sort)은 사이클이 없는 방향 그래프(directed acyclic graph)에서 각 정점들을 간선의 방향에 맞추어 나열한다. 깊이 우선 탐색에서와 달리 정점 <code class="language-plaintext highlighter-rouge">v</code>에서 출발하여 도착할 수 있는 정점들을 전부 방문한 후에 정점 <code class="language-plaintext highlighter-rouge">v</code>를 리스트에 담는다. 이때 정점 <code class="language-plaintext highlighter-rouge">v</code> 이전에 리스트에 담긴 정점들은 전부 정점 <code class="language-plaintext highlighter-rouge">v</code>에서 출발하여 도착할 수 있는 정점들이 되기에 리스트를 역순으로 출력하면 위상 정렬을 할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">TS</span><span class="p">(</span><span class="n">adj_list</span><span class="p">):</span>  <span class="c1"># adj_list는 인접리스트임
</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>  <span class="c1"># visited[i]의 값은 정점 i를 방문했다면 True이고 아니면 False임
</span>    <span class="n">TSlist</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 방문한 정점들이 담길 리스트임
</span>    
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># 정점 v에서부터 탐색 시작하기
</span>    
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 정점 v를 방문하기
</span>        
        <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 정점 v에서 출발하여 도착할 수 있는 정점들 adj_v에 대해
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v를 아직 방문하지 않았다면 
</span>                <span class="n">dfs</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>  <span class="c1"># adj_v에서부터 다시 탐색 시작하기
</span>                
        <span class="n">TSlist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 정점 v에서 출발하여 도착할 수 있는 정점들을 전부 방문했다면 리스트에 정점 v 담기
</span>        
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">TSlist</span><span class="p">))</span>
</code></pre></div></div>

<h1 id="너비-우선-탐색breadth-first-search">너비 우선 탐색(breadth first search)</h1>

<p>임의의 정점에서부터 너비 우선 탐색을 하는 경우 인접한 정점을 전부 방문한 다음에 그 인접한 정점들에 인접한 다른 정점을 전부 방문하는 식으로 탐색이 일어난다(트리에서의 레벨순회와 동일함).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">adj_list</span><span class="p">):</span>  <span class="c1"># adj_list는 인접리스트임
</span>    
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)</span>  <span class="c1"># visited[i]의 값은 정점 i를 방문했다면 True이고 아니면 False임
</span>    <span class="n">bfs_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 방문한 정점들이 담길 리스트임
</span>    
    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># 정점 v에서부터 탐색 시작하기
</span>    
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># 정점 v를 방문하기
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="c1"># 방문한 정점들을 담아둘 큐 만들기
</span>        
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 큐가 빌 때 까지
</span>        
            <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 큐에서 맨 앞에 있던 정점 v를 꺼내기
</span>            <span class="n">bfs_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># 이미 방문한 정점 v를 bfs_list에 담아주기
</span>            
            <span class="k">for</span> <span class="n">adj_v</span> <span class="ow">in</span> <span class="n">adj_list</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># 정점 v에 인접한 정점들 adj_v에 대해
</span>                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v를 아직 방문하지 않았다면
</span>                    <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># adj_v를 방문한 다음
</span>                    <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">adj_v</span><span class="p">)</span>  <span class="c1"># 큐에 담기
</span>    
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adj_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="n">bfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">bfs_list</span>
</code></pre></div></div>

<h1 id="최소-신장-트리minimum-spanning-tree">최소 신장 트리(minimum spanning tree)</h1>

<p>하나의 연결성분으로 이루어진 무방향 가중치 그래프에 대해 간선들의 가중치 합이 가장 작은 신장 트리를 최소 신장 트리(minimum spanning tree)라 한다. 최소 신장 트리를 찾기 위한 <code class="language-plaintext highlighter-rouge">Kruskal</code> 알고리즘과 <code class="language-plaintext highlighter-rouge">Prim</code> 알고리즘은 탐욕(greedy) 알고리즘의 일종으로 욕심내 선택한 지역적인 최적해를 누적해 전체적인 최적해를 얻는다. 수행 시간은 둘 다 \(O(ElogV)\)이다(\(V\)는 정점의 수이고 \(E\)는 간선의 수임).</p>

<h2 id="kruskal"><code class="language-plaintext highlighter-rouge">Kruskal</code></h2>

<p>주어진 그래프에 \(N\)개의 정점이 존재할 때 가중치가 가장 작은 간선이 사이클을 형성하지 않는다면 트리에 포함시키는 수행을 \(N - 1\)번 반복하면 최소 신장 트리를 얻을 수 있다.</p>

<p><img src="/images/2020-05-13-disjoint-set.png" alt="(2)" class="align-center" /></p>

<p>사이클이 생기는지를 검사하기 위해서는 서로소 집합(disjoint set) 자료구조를 사용한다. 임의의 두 집합을 선택했을 때 교집합이 공집합이 되는 집합들이 서로소 집합 자료구조를 구성하는데, 이때 존재하는 모든 집합들의 모든 원소가 \(0, 1, 2, \cdots, N - 1\)이라면 길이가 \(N\)인 리스트 <code class="language-plaintext highlighter-rouge">parent</code>에 서로소 집합을 저장할 수 있다. 하나의 집합을 하나의 트리로 나타낸 뒤에 <code class="language-plaintext highlighter-rouge">parent[i]</code>의 값을 <code class="language-plaintext highlighter-rouge">i</code>의 부모로 하면 되기 때문이다(<code class="language-plaintext highlighter-rouge">i</code>가 루트일 경우 <code class="language-plaintext highlighter-rouge">parent[i]</code>의 값은 <code class="language-plaintext highlighter-rouge">i</code>임). 예를 들어 위와 같은 서로소 집합 자료구조의 경우 <code class="language-plaintext highlighter-rouge">{2, 1, 3}</code>, <code class="language-plaintext highlighter-rouge">{5, 4}</code>, <code class="language-plaintext highlighter-rouge">{6}</code>, <code class="language-plaintext highlighter-rouge">{7}</code>이라는 집합으로 구성되며 <code class="language-plaintext highlighter-rouge">parent</code>는 <code class="language-plaintext highlighter-rouge">[None, 2, 2, 2, 5, 5, 6, 7]</code>가 됨을 알 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Kruskal</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>  <span class="c1"># graph는 (정점1, 정점2, 가중치)의 리스트
</span>                        <span class="c1"># N은 정점의 개수임
</span>
    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>  <span class="c1"># v의 루트 찾기
</span>        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># v가 루트가 아니라면
</span>            <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>  <span class="c1"># v의 부모에서 다시 find 수행하면서 경로 압축하기
</span>        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="c1"># v의 부모 반환하기
</span>    
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>  <span class="c1"># v1과 v2가 속한 집합을 합치기
</span>        <span class="n">root1</span><span class="p">,</span> <span class="n">root2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span> <span class="n">find</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>  <span class="c1"># v1과 v2의 루트 찾기
</span>        <span class="n">parent</span><span class="p">[</span><span class="n">root2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root1</span>  <span class="c1"># v2가 속한 집합의 루트의 부모를 v1의 루트로 갱신하기
</span></code></pre></div></div>

<p>서로소 집합에서 수행할 수 있는 연산에는 <code class="language-plaintext highlighter-rouge">find</code>와 <code class="language-plaintext highlighter-rouge">union</code>이 있다. <code class="language-plaintext highlighter-rouge">find(v)</code>는 <code class="language-plaintext highlighter-rouge">v</code>가 속한 집합의 루트를 반환한다. 이때 루트까지 올라가며 만나는 노드의 부모를 루트로 갱신하는 과정인 경로 압축(path compression)이 일어난다. 이는 추후 실행되는 <code class="language-plaintext highlighter-rouge">find</code> 연산의 수행 시간을 단축시킨다. <code class="language-plaintext highlighter-rouge">union(v1, v2)</code>는 <code class="language-plaintext highlighter-rouge">v1</code>과 <code class="language-plaintext highlighter-rouge">v2</code>가 속한 집합을 합치기 위해 <code class="language-plaintext highlighter-rouge">v2</code>가 속한 집합의 루트의 부모를 <code class="language-plaintext highlighter-rouge">v1</code>이 속한 집합의 루트로 갱신해준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">graph</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># graph를 가중치 순으로 정렬하기
</span>    
    <span class="n">parent</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 서로소 집합을 나타낼 리스트임
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>  <span class="c1"># 아직 트리에 포함된 정점이 없으므로
</span>        <span class="n">parent</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 각각의 정점의 루트는 자기 자신임
</span>        
    <span class="n">mst</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 트리에 포함시킬 간선들이 담길 리스트임
</span>    <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 트리에 포함된 간선들의 가중치 합임
</span>    
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst</span><span class="p">)</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 트리에 존재하는 간선이 N - 1개가 되면
</span>            <span class="k">break</span>  <span class="c1"># 실행 중지하기
</span>            
        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 가중치가 가장 작은 간선 뽑기
</span>        
        <span class="k">if</span> <span class="n">find</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">find</span><span class="p">(</span><span class="n">v2</span><span class="p">):</span>  <span class="c1"># v1과 v2가 다른 집합에 존재하면 사이클이 생기지 않으므로
</span>            <span class="n">mst</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>  <span class="c1"># 뽑은 간선을 트리에 추가하기
</span>            <span class="n">union</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>  <span class="c1"># v1과 v2가 트리에 추가되었으므로 v1과 v2가 속한 집합을 합치기
</span>            <span class="n">cost</span> <span class="o">+=</span> <span class="n">weight</span>  <span class="c1"># weight에 뽑은 간선의 가중치 더하기
</span>    
    <span class="k">return</span> <span class="n">mst</span><span class="p">,</span> <span class="n">cost</span>
</code></pre></div></div>

<h2 id="prim"><code class="language-plaintext highlighter-rouge">Prim</code></h2>

<p>주어진 그래프에 \(N\)개의 정점이 존재할 때 임의의 정점 <code class="language-plaintext highlighter-rouge">start</code>만을 가지는 트리에서 시작하여 트리에 속한 정점의 수가 \(N\)이 될 때 까지 트리에 인접한 정점들 중에서 가중치가 가장 작은 간선으로 연결된 것을 트리에 추가하는 작업을 반복하여 최소 신장 트리를 얻는다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">Prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span> <span class="c1"># graph[v]는 정점 v에 인접한 (정점, 가중치)의 리스트
</span>                           <span class="c1"># start는 트리에 처음으로 추가될 정점임
</span>                           <span class="c1"># N은 정점의 개수임
</span>    
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># visited[i]의 값은 정점 i가 트리에 속하면 True이고 아니면 False임    
</span>    <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> 
    <span class="n">previous</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># previous[i]의 값은 D[i]의 값을 갱신시킨 정점임 
</span>    
    <span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">previous</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span>
    
    <span class="n">vertices</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 트리에 추가된 정점의 수
</span>    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
     
        <span class="k">if</span> <span class="n">vertices</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>  <span class="c1"># 트리에 존재하는 정점의 수가 N이 되면
</span>            <span class="k">break</span>  <span class="c1"># 실행 중지하기
</span>        
        <span class="n">min_vertex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># min_vertex는 트리에 인접한 정점들 중 가중치가 가장 작은 간선으로 연결된 것임
</span>        <span class="n">min_value</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span>  <span class="c1"># min_value는 이 간선의 가중치임
</span>        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
                <span class="n">min_vertex</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                
        <span class="n">visited</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># min_vertex를 트리에 추가하기
</span>        <span class="n">vertices</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">adj_v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]:</span>  <span class="c1"># min_vertex에 인접한 정점들인 adj_v에 대해
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v가 트리에 속하지 않은 동시에
</span>                <span class="k">if</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># min_vertex와 adj_v를 잇는 간선의 가중치가 D[adj_v]보다 작다면
</span>                    <span class="n">D</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>  <span class="c1"># D[adj_v] 갱신하기
</span>                    <span class="n">previous</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_vertex</span>  <span class="c1"># D[adj_v]가 min_vertex에 의해 갱신되었음을 나타내기
</span>    
    <span class="n">mst</span> <span class="o">=</span> <span class="p">[[</span><span class="n">v</span><span class="p">,</span> <span class="n">previous</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)]</span>  <span class="c1"># mst는 트리에 추가된 간선들의 집합
</span>    <span class="n">cost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># cost는 트리에 추가된 간선들의 가중치 합
</span>    
    <span class="k">return</span> <span class="n">mst</span><span class="p">,</span> <span class="n">cost</span>
</code></pre></div></div>

<h1 id="최단-경로shortest-path">최단 경로(shortest path)</h1>

<p>주어진 가중치 그래프에서 출발 정점과 도착 정점을 연결하는 경로 중 간선의 가중치 합이 가장 작은 것을 찾는 방법에는 <code class="language-plaintext highlighter-rouge">Dijkstra</code> 알고리즘과 <code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 알고리즘이 있다.</p>

<h2 id="dijkstra"><code class="language-plaintext highlighter-rouge">Dijkstra</code></h2>

<p><code class="language-plaintext highlighter-rouge">Dijkstra</code> 알고리즘을 사용하면 주어진 출발 정점에서부터 나머지 정점들까지의 최단 경로를 구할 수 있다. <code class="language-plaintext highlighter-rouge">Prim</code> 알고리즘과 매우 유사하지만 <code class="language-plaintext highlighter-rouge">Dijkstra</code> 알고리즘의 경우 <code class="language-plaintext highlighter-rouge">D[i]</code>에 출발 정점에서 정점 <code class="language-plaintext highlighter-rouge">i</code>까지의 최단 경로의 길이(간선의 가중치의 합)가 저장된다는 점에서 차이가 있다. 수행시간은 \(O(V^{2})\)이다(\(V\)는 정점의 수임). 음수 가중치가 있는 경우에는 실패할 수 있다는 것이 단점이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span> <span class="c1"># graph[v]는 정점 v에 인접한 (정점, 가중치)의 리스트임
</span>                               <span class="c1"># start는 출발 정점임
</span>                               <span class="c1"># N은 정점의 개수임
</span>    
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># visited[i]의 값은 정점 i가 트리에 속하면 True이고 아니면 False임
</span>    <span class="n">D</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># D[i]의 값은 출발 정점에서 정점 i까지의 최단 거리임
</span>    <span class="n">previous</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># previous[i]의 값은 D[i]의 값을 갱신시킨 정점임
</span>    
    <span class="n">D</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">previous</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span>
    
    <span class="n">vertices</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">vertices</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>  <span class="c1"># 트리에 존재하는 정점의 수가 N이 되면
</span>            <span class="k">break</span>  <span class="c1"># 실행 중지하기
</span>        
        <span class="n">min_vertex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># min_vertex는 트리에 인접한 정점들 중 가중치가 가장 작은 간선으로 연결된 것임
</span>        <span class="n">min_value</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span>  <span class="c1"># min_value는 이 간선의 가중치임
</span>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">and</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
                <span class="n">min_vertex</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">vertices</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">for</span> <span class="n">adj_v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]:</span>  <span class="c1"># min_vertex에 인접한 정점들인 adj_v에 대해
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># adj_v가 트리에 속하지 않은 동시에
</span>                <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]:</span>  <span class="c1"># 출발 정점부터 min_vertex를 경유하여 adj_v로 가는 최단 거리가 기존 최단거리인 D[adj_v]보다 짧다면
</span>                    <span class="n">D</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">min_vertex</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span>  <span class="c1"># D[adj_v] 갱신하기
</span>                    <span class="n">previous</span><span class="p">[</span><span class="n">adj_v</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_vertex</span>  <span class="c1"># D[adj_v]가 min_vertex에 의해 갱신되었음을 나타내기
</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        
        <span class="n">v_path</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">D</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">sys</span><span class="p">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="n">v_path</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span>        
            <span class="n">prev_v</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">while</span> <span class="n">prev_v</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">v_path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_v</span><span class="p">)</span>
                <span class="n">prev_v</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">prev_v</span><span class="p">]</span>
            <span class="n">v_path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">v_path</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="n">path</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_path</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="floyd-warshall"><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code></h2>

<p><code class="language-plaintext highlighter-rouge">Floyd-Warshall</code> 알고리즘을 사용하면 모든 정점 쌍 사이의 최단경로를 얻을 수 있다. 수행 시간은 \(O(V^{3})\)이다(\(V\)는 정점의 수임). <code class="language-plaintext highlighter-rouge">Dijkstra</code> 알고리즘과 달리 음수 가중치가 있어도 성공한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">):</span>  <span class="c1"># adj_matrix는 인접행렬임
</span>                                 <span class="c1"># (adj[i][j]의 값은 정점 i와 j가 인접하면 간선의 가중치이고 아니면 sys.maxsize)
</span>    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">adj_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="n">adj_matrix</span><span class="p">[</span><span class="n">count</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adj_matrix</span>
</code></pre></div></div>

<p><strong>Reference</strong> 파이썬과 함께하는 자료구조의 이해 / 양성봉 지음 / 생능출판사</p>

        </div>

        
          <div class="page-share">
  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fdata%2520structure%2Fgraph%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--facebook btn--small"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> <span>Share</span></a>
  <a href="https://twitter.com/intent/tweet?text=%ED%8C%8C%EC%9D%B4%EC%8D%AC+%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%3A+%EA%B7%B8%EB%9E%98%ED%94%84%20http%3A%2F%2Flocalhost%3A4000%2Fdata%2520structure%2Fgraph%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--twitter btn--small"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i> <span>Tweet</span></a>
  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fdata%2520structure%2Fgraph%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--linkedin btn--small"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> <span>LinkedIn</span></a>
  <a href="https://reddit.com/submit?title=%ED%8C%8C%EC%9D%B4%EC%8D%AC+%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%3A+%EA%B7%B8%EB%9E%98%ED%94%84&url=http%3A%2F%2Flocalhost%3A4000%2Fdata%2520structure%2Fgraph%2F" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" class="btn btn--reddit btn--small"><i class="fab fa-fw fa-reddit" aria-hidden="true"></i> <span>Reddit</span></a>
</div>

        

        

        <nav class="page-pagination" role="navigation">
  
    <a class="page-previous" href="/data%20structure/search-tree/">
      <h4 class="page-pagination-label">Previous</h4>
      <span class="page-pagination-title">
        <i class="fas fa-arrow-left"></i> 파이썬 자료구조: 탐색트리

      </span>
    </a>
  

  
</nav>

      </div>
    </div>
  </article>
</main>


    <footer id="footer" class="site-footer">
  <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
<div class="social-icons"><a class="social-icon" href="https://github.com/boreum0302"><i class="fab fa-github-square fa-2x" title="GitHub"></i></a><a class="social-icon" href="mailto:bureom0302@gmail.com"><i class="fas fa-envelope-square fa-2x" title="e-mail"></i></a></div><div class="copyright">
    
      <p>Powered by <a href="https://jekyllrb.com/"><strong>Jekyll</strong></a> and <a href="https://github.com/mmistakes/so-simple-theme"><strong>So Simple Theme</strong></a>.</p>

    
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.12/js/all.js"></script>


<!-- MathJax -->

<script>
// http://docs.mathjax.org/en/latest/upgrading/v2.html
MathJax = {
  tex: {
      tags: "ams"    // eq numbering options: none, ams, all
  },
  options: {
    renderActions: {
      // for mathjax 3, handle <script "math/tex"> blocks inserted by kramdown
      find: [10, function (doc) {
        for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
          const display = !!node.type.match(/; *mode=display/);
          const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
          const text = document.createTextNode('');
          node.parentNode.replaceChild(text, node);
          math.start = {node: text, delim: '', n: 0};
          math.end = {node: text, delim: '', n: 0};
          doc.math.push(math);
        }
      }, '']
    }
  }
}
</script>

<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  </body>

</html>
